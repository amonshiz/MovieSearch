# Design Considerations
- The search is a standard `UITableView` because it is simple to implement and provides the basic features out of the box. However, with more time and iOS 14+ it would likely be more appropriate to use a list styled `UICollectionView` with its declarative and compositional layout styles. Or even using something like `IGListKit` to make management of the collection view mapping from data to cells easier.
- The detail view controller is … not pretty. I am not a designer. I think something where the poster is the background for the entire view and then content like the ratings and details are presented via a vibrancy effect in a blurred section could be interesting. That would present various accessibility issues, but again those are solvable. But, I didn’t want to spend too much time on this view, so did the basics.

# Implementations
- I stayed away from using third party libraries as requested. This means that I ended up implementing features that are generally pushed off to common frameworks/libraries like AlamoFire or SDWebImage.
- Loading images uses an object that manages mapping URLs to existing data tasks to ensure that no more than one task is ever downloading a single image. However, this does not currently guarantee that the same image is not requested by different cells, which is an implicit assumption. That could be handled by adding a second map to the `ImageFetcher` class that maps the URL to the completion block, and then once the data task completes the various completion blocks are invoked and then both maps are cleared of the mapping.
- The object that interacts with the OMDb API is independent of the objects used to serialize data to the final model objects. Doing this makes it easier to add mocks or other test setups. Which also means it is easier to add new API objects that conform to the same protocol.
- There is some log spew if the user starts to load some results in the search view and then causes that load to cancel (or by association the poster image loads). This is because without a delegate to manage the cancel case for the `URLSession` it spits out messages like below when a task is canceled. This is a harmless error.
```
2020-07-01 12:54:31.510575-0400 MovieSearch[2714:95931] Task <BD5C7625-02B3-4C6A-A632-A80738461C48>.<41> finished with error [-999] Error Domain=NSURLErrorDomain Code=-999 "cancelled" UserInfo={NSErrorFailingURLStringKey=https://m.media-amazon.com/images/M/MV5BNWVlZDI1MTEtNGMxMS00ZWUyLWE4MDAtYzE5MzY0YjA2ZWM0XkEyXkFqcGdeQXVyMjQzMzQzODY@._V1_SX300.jpg, NSLocalizedDescription=cancelled, NSErrorFailingURLKey=https://m.media-amazon.com/images/M/MV5BNWVlZDI1MTEtNGMxMS00ZWUyLWE4MDAtYzE5MzY0YjA2ZWM0XkEyXkFqcGdeQXVyMjQzMzQzODY@._V1_SX300.jpg}
```
- The `Debouncer` object is to coalesce typing events so that there isn’t a new network request fired off every time. The current implementation uses `-[NSObject performSelector:withObject:afterDelay:]` and `+[NSObject cancelPreviousPerformRequestsWithTarget:]` to manage that coalescence.
- The `SearchViewController` manages the display of the empty, loading, and results view controllers. This is currently implemented as the view controller knowing how to transition between all those states but could be (potentially better) managed by an explicit state machine. This machine then could also know what the last completed search was and avoid the current behavior of where a loading view is displayed when the user makes the search bar first responder even though no text has changed. Another way to avoid this behavior would be to implement more than just `UISearchResultsUpdating` and be a complete delegate for the embedded search text field.
